<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-08-31T15:24:31+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Max Note</title><subtitle>An amazing website.</subtitle><author><name>Max</name><email>maxkim7723@gmail.com</email></author><entry><title type="html">[CodingTest] Printing a String in Java</title><link href="http://localhost:4000/codingtest/CodingtestJavaPrint/" rel="alternate" type="text/html" title="[CodingTest] Printing a String in Java" /><published>2024-08-28T00:00:00+09:00</published><updated>2024-08-28T00:00:00+09:00</updated><id>http://localhost:4000/codingtest/CodingtestJavaPrint</id><content type="html" xml:base="http://localhost:4000/codingtest/CodingtestJavaPrint/"><![CDATA[<p><img src="/assets/images/2024-08-28-PrintingaStringinJava/2.png" alt="Codingtest" /></p>

<h1 id="printing-a-string-in-java">Printing a String in Java</h1>

<h3 id="problem-description">Problem Description</h3>

<p>In this post, we’ll explore how to take a string as input and print it in Java. This is a fundamental exercise in understanding basic input/output operations in Java programming.</p>

<p><strong>Problem Statement</strong></p>

<p>Given a string <code class="language-plaintext highlighter-rouge">str</code>, write a program that reads the string and prints it.</p>

<p><strong>Constraints</strong></p>

<ul>
  <li>The length of <code class="language-plaintext highlighter-rouge">str</code> is between 1 and 1,000,000 characters.</li>
  <li>The string <code class="language-plaintext highlighter-rouge">str</code> contains no spaces and is provided in a single line.</li>
</ul>

<h3 id="example-input-and-output">Example Input and Output</h3>

<p><strong>Example Input</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input #1:

HelloWorld!
</code></pre></div></div>

<p><strong>Example Output</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Output #1:

HelloWorld!
</code></pre></div></div>

<h3 id="java-code-implementation">Java Code Implementation</h3>

<details>
    <summary>Details</summary>

<pre><code>

import java.util.Scanner;

public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in); // Step 1: Create a Scanner object to read input
        String a = sc.next();               // Step 2: Read a single word (without spaces) from the input
        System.out.println(a);              // Step 3: Print the input string
    }
}

</code></pre>

</details>

<h3 id="code-explanation">Code Explanation</h3>

<details>
    <summary>Details</summary>
1. Scanner sc = new Scanner(System.in);
<br />
Here, we create an instance of the Scanner class, named sc, which reads from the standard input (System.in). This allows us to take input from the user.
<br />
<br />
2. String a = sc.next();
<br />
This line reads the next token of input as a string. The next() method of Scanner reads input until a space is encountered, making it ideal for reading a single word.
<br />
<br />
3. System.out.println(a);
<br />
Finally, this line prints the string a to the console. The println method is used to print the output followed by a newline.
<br />
<br />
</details>

<h3 id="concept-summary">Concept Summary</h3>

<ul>
  <li>Scanner Class</li>
</ul>

<p>The Scanner class in Java is a utility that allows for simple input reading from different input streams, like the keyboard. It’s part of the java.util package, which must be imported to use the class.</p>

<ul>
  <li>Main Method</li>
</ul>

<p>The main method serves as the entry point for any Java program. When the program is run, execution begins here.</p>

<ul>
  <li>Reading Input</li>
</ul>

<p>The next() method of the Scanner object reads the next token from the input until it encounters a space. It’s used to read a single word or a string without spaces.</p>

<ul>
  <li>Printing Output</li>
</ul>

<p>The System.out.println() method is used to print the output to the console, followed by a newline.</p>

<p>This program demonstrates a basic input/output operation in Java. It reads a single string from the user and prints it back, showcasing how to handle simple input and output in a Java program.</p>

<p>This example is a foundational exercise in Java programming, highlighting how to work with basic input and output. Understanding these concepts is crucial as they form the basis for more complex operations and interactions in Java applications. This program can be run in any standard Java environment and is a great starting point for beginners.</p>

<h1 id="print-a-and-b">Print <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code></h1>

<h3 id="problem-description-1">Problem Description</h3>

<p>You are given two integers, <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>. Write a code to take these numbers as input and print them in the format shown in the example.</p>

<h3 id="constraints">Constraints</h3>

<ul>
  <li>100,000 ≤ a, b ≤ 100,000</li>
</ul>

<h3 id="inputoutput-example">Input/Output Example</h3>

<p><strong>Input #1</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4 5
</code></pre></div></div>

<p><strong>Output #1</strong></p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">a</span> <span class="o">=</span> <span class="err">4</span>
<span class="nt">b</span> <span class="o">=</span> <span class="err">5</span>

</code></pre></div></div>

<h3 id="solutionjava">Solution.java</h3>

<details>
    <summary>Details</summary>

<pre><code>
import java.util.Scanner;

public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();

        System.out.println("a = " + a);
        System.out.println("b = " + b);
    }
}
</code></pre>

</details>

<h3 id="explanation-and-concept-overview">Explanation and Concept Overview</h3>

<details>
    <summary>Details</summary>

The task is to read two integers, `a` and `b`, from the user input and print them in a specified format. This is a straightforward problem that tests basic input/output operations in Java.

1. Input
<br />
    - The program uses `Scanner` to read two integers from the user.
<br />
    - `sc.nextInt()` reads the next integer from the input.

2. Output
<br />
    - The program then prints the values of `a` and `b` in the format "a = value" and "b = value".
<br />
    - This is done using `System.out.println()` where the string concatenation operator (`+`) is used to combine the text with the variable values.
<br />
</details>

<h3 id="concept-overview">Concept Overview</h3>

<ul>
  <li>
    <p><strong>Basic Input/Output</strong></p>

    <p>This problem emphasizes understanding how to take input from the user and how to output the data in a specific format. It’s fundamental for beginners to grasp how input and output work in Java.</p>
  </li>
  <li>
    <p><strong>String Concatenation</strong></p>

    <p>The problem also involves string concatenation, where you combine strings and variables to create a desired output format.</p>
  </li>
  <li>
    <p><strong>Using the <code class="language-plaintext highlighter-rouge">Scanner</code> Class:</strong></p>

    <p>The <code class="language-plaintext highlighter-rouge">Scanner</code> class is a part of the <code class="language-plaintext highlighter-rouge">java.util</code> package, and it is widely used for taking input in Java. This problem introduces or reinforces the use of <code class="language-plaintext highlighter-rouge">Scanner</code> to read integers from standard input.</p>
  </li>
</ul>

<p>This problem is a basic exercise in handling input and output in Java, useful for beginners to get accustomed to reading input and printing formatted output.</p>

<h1 id="toggle-case-and-print">Toggle Case and Print</h1>

<h3 id="problem-description-2">Problem Description</h3>

<p>You are given a string <code class="language-plaintext highlighter-rouge">str</code> composed of English alphabets. Write a code to convert each alphabet in the string to its opposite case (uppercase to lowercase, and lowercase to uppercase) and then print the result.</p>

<h3 id="constraints-1">Constraints</h3>

<ul>
  <li>The length of <code class="language-plaintext highlighter-rouge">str</code> is between 1 and 20 inclusive.</li>
  <li><code class="language-plaintext highlighter-rouge">str</code> consists of alphabetic characters only.</li>
</ul>

<h3 id="inputoutput-example-1">Input/Output Example</h3>

<p><strong>Input #1</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aBcDeFg

</code></pre></div></div>

<p><strong>Output #1</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AbCdEfG
</code></pre></div></div>

<p>※ The constraints were updated on May 3, 2023.</p>
<h3 id="solution">Solution</h3>

<details>
    <summary>Details</summary>
    <pre><code>
import java.util.Scanner;

public class Solution {
    public static void main(String[] args) {
        // Create a Scanner object to read input
        Scanner sc = new Scanner(System.in);
        
        // Read the input string
        String a = sc.next();
        
        // Create a variable to store the result
        String answer = "";
        
        // Variable to store each character
        char c;
        
        // Loop through each character in the input string
        for(int i = 0; i &lt; a.length(); i++) {
            // Get the character at the current position in the string
            c = a.charAt(i);
            
            // Check if the character is uppercase
            if(Character.isUpperCase(c)) {
                // Convert to lowercase and append to the result
                answer += Character.toLowerCase(c); 
            } else {
                // Convert to uppercase and append to the result
                answer += Character.toUpperCase(c);
            }
        }
        
        // Print the final result
        System.out.println(answer);        
    }
}

</code></pre>

</details>

<h3 id="conceptual-explanation">Conceptual Explanation</h3>
<ol>
  <li><strong>Input Handling</strong>
    <ul>
      <li>The code begins by creating a <code class="language-plaintext highlighter-rouge">Scanner</code> object to read the input string from the user. The <code class="language-plaintext highlighter-rouge">sc.next()</code> function reads the next token of input (in this case, a string) and stores it in the variable <code class="language-plaintext highlighter-rouge">a</code>.</li>
    </ul>
  </li>
  <li><strong>Variable Initialization</strong>
    <ul>
      <li>The variable <code class="language-plaintext highlighter-rouge">answer</code> is initialized as an empty string. This variable will be used to store the final output after converting each character to its opposite case.</li>
      <li>The variable <code class="language-plaintext highlighter-rouge">c</code> is declared to temporarily store each character from the string during the loop.</li>
    </ul>
  </li>
  <li><strong>Looping through the String</strong>
    <ul>
      <li>A <code class="language-plaintext highlighter-rouge">for</code> loop iterates over each character in the string <code class="language-plaintext highlighter-rouge">a</code>. The loop runs from index <code class="language-plaintext highlighter-rouge">0</code> to the length of the string minus one.</li>
    </ul>
  </li>
  <li><strong>Character Case Conversion</strong>
    <ul>
      <li>Inside the loop, the <code class="language-plaintext highlighter-rouge">charAt(i)</code> method is used to get the character at the current index <code class="language-plaintext highlighter-rouge">i</code> of the string.</li>
      <li>The <code class="language-plaintext highlighter-rouge">Character.isUpperCase(c)</code> method checks if the character <code class="language-plaintext highlighter-rouge">c</code> is uppercase.
        <ul>
          <li>If <code class="language-plaintext highlighter-rouge">c</code> is uppercase, it is converted to lowercase using <code class="language-plaintext highlighter-rouge">Character.toLowerCase(c)</code>, and the result is appended to the <code class="language-plaintext highlighter-rouge">answer</code> string.</li>
          <li>If <code class="language-plaintext highlighter-rouge">c</code> is lowercase, it is converted to uppercase using <code class="language-plaintext highlighter-rouge">Character.toUpperCase(c)</code>, and the result is appended to the <code class="language-plaintext highlighter-rouge">answer</code> string.</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>https://docs.oracle.com/javase/8/docs/api/</p>

  <ul>
    <li>
      <p>toLowerCaseConverts the character (Unicode code point) argument to lowercase using case mapping information from the UnicodeData file.</p>

      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public static int toLowerCase(int codePoint)
</code></pre></div>      </div>

      <p>Note that <code class="language-plaintext highlighter-rouge">Character.isLowerCase(Character.toLowerCase(codePoint))</code> does not always return <code class="language-plaintext highlighter-rouge">true</code> for some ranges of characters, particularly those that are symbols or ideographs.</p>

      <p>In general, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toLowerCase--"><code class="language-plaintext highlighter-rouge">String.toLowerCase()</code></a> should be used to map characters to lowercase. <code class="language-plaintext highlighter-rouge">String</code> case mapping methods have several benefits over <code class="language-plaintext highlighter-rouge">Character</code> case mapping methods. <code class="language-plaintext highlighter-rouge">String</code> case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the <code class="language-plaintext highlighter-rouge">Character</code> case mapping methods cannot.</p>

      <p><strong>Parameters:</strong><code class="language-plaintext highlighter-rouge">codePoint</code> - the character (Unicode code point) to be converted.<strong>Returns:</strong>the lowercase equivalent of the character (Unicode code point), if any; otherwise, the character itself.<strong>Since:</strong>1.5<strong>See Also:</strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isLowerCase-int-"><code class="language-plaintext highlighter-rouge">isLowerCase(int)</code></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toLowerCase--"><code class="language-plaintext highlighter-rouge">String.toLowerCase()</code></a></p>
    </li>
  </ul>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static char toUpperCase(char ch)
</code></pre></div>  </div>

  <p>Converts the character argument to uppercase using case mapping information from the UnicodeData file.</p>

  <p>Note that <code class="language-plaintext highlighter-rouge">Character.isUpperCase(Character.toUpperCase(ch))</code> does not always return <code class="language-plaintext highlighter-rouge">true</code> for some ranges of characters, particularly those that are symbols or ideographs.</p>

  <p>In general, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toUpperCase--"><code class="language-plaintext highlighter-rouge">String.toUpperCase()</code></a> should be used to map characters to uppercase. <code class="language-plaintext highlighter-rouge">String</code> case mapping methods have several benefits over <code class="language-plaintext highlighter-rouge">Character</code> case mapping methods. <code class="language-plaintext highlighter-rouge">String</code> case mapping methods can perform locale-sensitive mappings, context-sensitive mappings, and 1:M character mappings, whereas the <code class="language-plaintext highlighter-rouge">Character</code> case mapping methods cannot.</p>

  <p><strong>Note:</strong> This method cannot handle <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#supplementary">supplementary characters</a>. To support all Unicode characters, including supplementary characters, use the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#toUpperCase-int-"><code class="language-plaintext highlighter-rouge">toUpperCase(int)</code></a> method.</p>

  <p><strong>Parameters:</strong><code class="language-plaintext highlighter-rouge">ch</code> - the character to be converted.<strong>Returns:</strong>the uppercase equivalent of the character, if any; otherwise, the character itself.<strong>See Also:</strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isUpperCase-char-"><code class="language-plaintext highlighter-rouge">isUpperCase(char)</code></a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toUpperCase--"><code class="language-plaintext highlighter-rouge">String.toUpperCase()</code></a></p>

</blockquote>

<p><strong>Breif</strong></p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">print</code></strong></li>
</ul>

<p>Outputs data as-is, stays on the same line.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">println</code></strong></li>
</ul>

<p>Outputs data as-is, then moves to a new line.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">printf</code></strong></li>
</ul>

<p>Formats and outputs data according to a specified format, stays on the same line unless explicitly told to move to the next line.</p>

<h3 id="summary">Summary</h3>

<p>This code efficiently toggles the case of each character in a string provided by the user. It demonstrates the use of loops, conditionals, and basic string operations in Java. The approach ensures that every character is checked and converted appropriately, resulting in the desired output.</p>]]></content><author><name>Max</name><email>maxkim7723@gmail.com</email></author><category term="CodingTest" /><category term="CS" /><category term="Java" /><category term="Programming" /><category term="Input/Output" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[CS] Understanding Asynchronous Transfer Mode (ATM) and Asynchronous Time-Division Multiplexing (ATDM)</title><link href="http://localhost:4000/cs/ATM/" rel="alternate" type="text/html" title="[CS] Understanding Asynchronous Transfer Mode (ATM) and Asynchronous Time-Division Multiplexing (ATDM)" /><published>2024-07-25T00:00:00+09:00</published><updated>2024-07-25T00:00:00+09:00</updated><id>http://localhost:4000/cs/ATM</id><content type="html" xml:base="http://localhost:4000/cs/ATM/"><![CDATA[<p><img src="/assets/images/2024-07-11-CSQuiz1/quiz.png" alt="CSQuiz" /></p>

<h1 id="understanding-asynchronous-transfer-mode-atm-and-asynchronous-time-division-multiplexing-atdm">Understanding Asynchronous Transfer Mode (ATM) and Asynchronous Time-Division Multiplexing (ATDM)</h1>

<h3 id="quiz-question">Quiz Question</h3>

<p><strong>Question:</strong>
Which of the following statements is true regarding Asynchronous Transfer Mode (ATM) and Asynchronous Time-Division Multiplexing (ATDM)?</p>

<p>A. ATM uses variable-length packets for data transmission, while ATDM uses fixed-length cells.</p>

<p>B. ATDM is a specific protocol, whereas ATM is a general multiplexing technique.</p>

<p>C. ATM is connection-oriented and uses fixed-length 53-byte cells, while ATDM dynamically allocates time slots based on demand.</p>

<p>D. In ATM, each type of data is assigned a specific time slot in a repeating cycle, similar to Time-Division Multiplexing (TDM).</p>

<p><strong>Answer:</strong>
C. ATM is connection-oriented and uses fixed-length 53-byte cells, while ATDM dynamically allocates time slots based on demand.</p>

<h3 id="explanation">Explanation</h3>
<ul>
  <li><strong>Option A</strong> is incorrect because ATM uses fixed-length cells (53 bytes), not variable-length packets.</li>
  <li><strong>Option B</strong> is incorrect because ATDM is a general multiplexing technique, while ATM is a specific protocol that uses ATDM principles.</li>
  <li><strong>Option D</strong> is incorrect because ATM does not use fixed time slots in a repeating cycle; it dynamically allocates bandwidth as needed.</li>
  <li><strong>Option C</strong> is correct as it accurately describes the characteristics of both ATM and ATDM.</li>
</ul>

<p>In the world of network technologies, two important concepts often come up: Asynchronous Transfer Mode (ATM) and Asynchronous Time-Division Multiplexing (ATDM). While these terms are closely related, they have distinct characteristics and applications. Let’s dive deeper into these technologies to understand their similarities, differences, and how they work together.</p>

<h2 id="what-is-asynchronous-transfer-mode-atm">What is Asynchronous Transfer Mode (ATM)?</h2>

<p>ATM is a high-speed networking standard designed for transmitting all types of data (such as voice, video, and data traffic) across a network. It is a packet-oriented transmission technology that uses fixed-size cells for data transfer. Each ATM cell is 53 bytes in length, consisting of a 5-byte header and a 48-byte payload.</p>

<h3 id="key-features-of-atm">Key Features of ATM</h3>

<ol>
  <li>
    <p><strong>Fixed-Length Cells</strong>: Unlike other networking protocols that use variable-length packets, ATM uses fixed-length cells of 53 bytes. This standardization simplifies hardware processing and helps maintain consistent transmission delays.</p>
  </li>
  <li>
    <p><strong>Asynchronous Time-Division Multiplexing (ATDM)</strong>: ATM leverages the concept of ATDM, which means that data cells are transmitted asynchronously. Instead of using fixed time slots, each data stream dynamically receives time slots as needed, making efficient use of network resources.</p>
  </li>
  <li>
    <p><strong>Connection-Oriented</strong>: ATM is a connection-oriented protocol. Before data transmission begins, a virtual circuit is established, specifying the path that data will follow through the network. This ensures reliable and consistent data delivery.</p>
  </li>
  <li>
    <p><strong>Quality of Service (QoS)</strong>: ATM supports various levels of Quality of Service (QoS), making it suitable for applications with different performance requirements. It can handle diverse types of traffic, including real-time voice and video, as well as non-real-time data.</p>
  </li>
</ol>

<h2 id="what-is-asynchronous-time-division-multiplexing-atdm">What is Asynchronous Time-Division Multiplexing (ATDM)?</h2>

<p>ATDM is a general multiplexing technique where multiple data streams share the same communication channel by being assigned time slots based on demand. Unlike synchronous time-division multiplexing (TDM), where time slots are fixed, ATDM dynamically allocates time slots to data streams as needed.</p>

<h3 id="key-features-of-atdm">Key Features of ATDM</h3>

<ol>
  <li>
    <p><strong>Dynamic Time Slot Allocation</strong>: ATDM allocates time slots to data streams on an as-needed basis. This means that the channel’s time slots are not fixed and can be used more efficiently by only assigning them when there is data to be transmitted.</p>
  </li>
  <li>
    <p><strong>Efficient Bandwidth Utilization</strong>: By dynamically allocating time slots, ATDM makes better use of the available bandwidth, minimizing idle periods and improving overall transmission efficiency.</p>
  </li>
  <li>
    <p><strong>Flexibility</strong>: ATDM is not tied to a specific protocol and can be implemented in various systems and networks to accommodate different types of traffic and transmission requirements.</p>
  </li>
</ol>

<h2 id="how-atm-and-atdm-work-together">How ATM and ATDM Work Together</h2>

<p>ATM uses ATDM as its underlying multiplexing technique. Here’s how they integrate:</p>

<ul>
  <li><strong>Packet-Oriented Transmission</strong>: ATM’s use of fixed-length 53-byte cells ensures predictable performance and simplifies hardware design.</li>
  <li><strong>Efficient Use of Network Resources</strong>: By employing ATDM, ATM can dynamically allocate time slots for transmitting cells, maximizing the efficiency of the network.</li>
  <li><strong>Connection-Oriented Communication</strong>: ATM sets up a virtual circuit before data transmission, ensuring a reliable and continuous data stream. This connection-oriented nature, combined with ATDM’s efficient time slot allocation, makes ATM suitable for a wide range of applications with varying QoS requirements.</li>
</ul>

<h2 id="diagram-explanation">Diagram Explanation</h2>

<p><img src="/assets/images/2024-07-25-ATM/1.png" alt="Asynchronous Transfer Mode (ATM)" /></p>

<p>This diagram illustrates the concept of ATM and its comparison with TDM. Let’s break down the components and what they represent.</p>

<h3 id="diagram-breakdown">Diagram Breakdown</h3>

<ol>
  <li><strong>Sources of Data</strong>
    <ul>
      <li><strong>Voice</strong>: Represented by gray blocks.</li>
      <li><strong>Data Packets</strong>: Represented by black blocks.</li>
      <li><strong>Images</strong>: Represented by light gray blocks.</li>
    </ul>
  </li>
  <li><strong>Multiplexer (MUX)</strong>
    <ul>
      <li>The MUX is responsible for combining multiple streams of data (voice, data packets, and images) into a single stream for transmission. It acts as a central point where different types of data are synchronized and sent out over the network.</li>
    </ul>
  </li>
  <li><strong>TDM (Time-Division Multiplexing)</strong>
    <ul>
      <li>In TDM, each type of data is assigned a specific time slot in a repeating cycle. For example, voice data might be sent in slot 1, data packets in slot 2, and images in slot 3, and so on.</li>
      <li><strong>Wasted Bandwidth</strong>: TDM can lead to inefficiencies. If a particular time slot has no data to send (e.g., no voice data during a given cycle), that slot is left empty, resulting in wasted bandwidth.</li>
    </ul>
  </li>
  <li><strong>ATM (Asynchronous Transfer Mode)</strong>
    <ul>
      <li>In ATM, data is sent in small, fixed-size cells (53 bytes). Each cell can carry different types of data depending on availability and demand.</li>
      <li>Unlike TDM, ATM does not use fixed time slots. Instead, it dynamically allocates bandwidth as needed. This means there are no empty slots, and bandwidth is used more efficiently.</li>
    </ul>
  </li>
</ol>

<p>In summary, Asynchronous Transfer Mode (ATM) is a sophisticated network technology that combines the principles of Asynchronous Time-Division Multiplexing (ATDM) with fixed-length cells to achieve efficient, reliable, and high-speed data transmission. Understanding the interplay between ATM and ATDM helps in appreciating how modern networks manage diverse types of traffic, ensuring seamless communication and optimal resource utilization. Whether for voice, video, or data, ATM remains a powerful solution for meeting the demands of contemporary networking.</p>]]></content><author><name>Max</name><email>maxkim7723@gmail.com</email></author><category term="CS" /><category term="CS" /><category term="Knowledge" /><category term="Quiz" /><category term="ATM" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[CS] Understanding the Role of the Network Layer and Virtual Circuits&amp;amp;Datagram</title><link href="http://localhost:4000/cs/vcdatagram/" rel="alternate" type="text/html" title="[CS] Understanding the Role of the Network Layer and Virtual Circuits&amp;amp;Datagram" /><published>2024-07-24T00:00:00+09:00</published><updated>2024-07-24T00:00:00+09:00</updated><id>http://localhost:4000/cs/vcdatagram</id><content type="html" xml:base="http://localhost:4000/cs/vcdatagram/"><![CDATA[<p><img src="/assets/images/2024-07-11-CSQuiz1/quiz.png" alt="CSQuiz" /></p>

<h1 id="understanding-the-role-of-the-network-layer-and-virtual-circuits--datagram">Understanding the Role of the Network Layer and Virtual Circuits &amp; Datagram</h1>

<h3 id="quiz-question">Quiz Question</h3>

<p><strong>Question:</strong>
Which of the following statements accurately describes the difference between virtual circuit networks and datagram networks?</p>

<p>A. Virtual circuit networks do not require a call setup before data transmission, whereas datagram networks require a call setup.</p>

<p>B. Datagram networks guarantee sequential delivery and minimum bandwidth, whereas virtual circuit networks do not provide these guarantees.</p>

<p>C. Virtual circuit networks require a call setup and teardown process, and involve cooperation between routers and hosts, whereas datagram networks treat each packet independently and do not require a setup process.</p>

<p>D. In virtual circuit networks, each packet is routed independently with no fixed path, whereas in datagram networks, a fixed path is established for the duration of the connection.</p>

<p><strong>Answer:</strong>
C. Virtual circuit networks require a call setup and teardown process, and involve cooperation between routers and hosts, whereas datagram networks treat each packet independently and do not require a setup process.</p>

<h3 id="explanation">Explanation:</h3>
<ul>
  <li><strong>Option A</strong> is incorrect because it reverses the requirements for call setup between virtual circuit and datagram networks.</li>
  <li><strong>Option B</strong> is incorrect because datagram networks do not guarantee sequential delivery or minimum bandwidth; these are characteristics that can be provided by virtual circuit networks.</li>
  <li><strong>Option D</strong> is incorrect because it reverses the routing method of virtual circuit and datagram networks.</li>
  <li><strong>Option C</strong> is correct as it accurately describes the fundamental differences between virtual circuit networks and datagram networks.</li>
</ul>

<h2 id="understanding-the-role-of-the-network-layer-and-virtual-circuits">Understanding the Role of the Network Layer and Virtual Circuits</h2>

<p>The network layer’s primary role is to deliver transport layer segments from the sending host to the receiving host. This layer is crucial in ensuring that data travels from one host to another efficiently and accurately.</p>

<h2 id="network-layer-functions">Network Layer Functions</h2>

<h3 id="sending-and-receiving-data">Sending and Receiving Data</h3>

<p>On the sending side, the network layer encapsulates transport layer segments into datagrams by adding headers and then passes them down to the data link layer. On the receiving side, it receives these datagrams, removes the headers, and delivers the segments to the transport layer.</p>

<h3 id="presence-in-hosts-and-routers">Presence in Hosts and Routers</h3>

<p>Network layer protocols are not only present in hosts but also in routers, which play a pivotal role in routing and forwarding data across networks.</p>

<h3 id="basic-functions-routing-and-forwarding">Basic Functions: Routing and Forwarding</h3>

<ol>
  <li><strong>Routing</strong>: This involves determining the path that data packets should take to reach their destination. It is the process of path calculation for each destination.</li>
  <li><strong>Forwarding</strong>: When a packet arrives at an input port, forwarding determines which output port the packet should be sent to next.</li>
</ol>

<h3 id="interplay-between-routing-and-forwarding">Interplay Between Routing and Forwarding</h3>

<p>Routers use routing algorithms to compute the routes to all destinations and store this information in a forwarding table. This table maps header values to output ports, ensuring efficient data packet forwarding.</p>

<h2 id="network-service-models">Network Service Models</h2>

<p>When discussing network service models, it’s essential to consider whether we’re dealing with individual datagrams or a flow of datagrams.</p>

<h2 id="datagrams">Datagrams</h2>
<p><img src="/assets/images/2024-07-24-vcdatagram/1.png" alt="Datagram" /></p>

<ul>
  <li><strong>Guaranteed Delivery</strong>: Ensures that each datagram is delivered.</li>
  <li><strong>Guaranteed Delivery Time</strong>: Ensures delivery within a specified time frame (e.g., 40 milliseconds).</li>
</ul>

<h3 id="flow-of-datagrams">Flow of Datagrams</h3>

<ul>
  <li><strong>Sequential Delivery</strong>: Ensures datagrams arrive in the order they were sent.</li>
  <li><strong>Minimal Bandwidth Guarantee</strong>: Ensures a minimum transmission capacity.</li>
  <li><strong>Bounded Delay</strong>: Limits the variation in packet delivery times.</li>
</ul>

<h2 id="virtual-circuit-and-datagram-networks">Virtual Circuit and Datagram Networks</h2>

<p>Packet switching can be categorized into virtual circuit and datagram networks.</p>

<h3 id="datagram-networks">Datagram Networks</h3>

<ul>
  <li><strong>Connectionless Service</strong>: Each packet is treated independently, and no setup is required before sending data.</li>
</ul>

<h3 id="virtual-circuit-networks">Virtual Circuit Networks</h3>

<ul>
  <li><strong>Connection-Oriented Service</strong>: Requires a call setup before data transmission. It is similar to the concept of connections in the transport layer but involves cooperation between all routers and hosts within the network core.</li>
</ul>

<h3 id="comparison-with-transport-layer">Comparison with Transport Layer</h3>

<ul>
  <li><strong>Transport Layer (TCP/UDP)</strong>: Operates end-to-end between hosts (process-to-process communication).</li>
  <li><strong>Network Layer</strong>: Operates from host to host, involving all routers along the path.</li>
</ul>

<h2 id="virtual-circuits">Virtual Circuits</h2>
<p><img src="/assets/images/2024-07-24-vcdatagram/2.png" alt="Virtual Circuits" /></p>

<h3 id="call-setup-and-teardown">Call Setup and Teardown</h3>

<p>Before data is transmitted, a call setup phase is required to establish the path and resources. Similarly, a teardown phase is required to terminate the connection.</p>

<h3 id="virtual-circuit-implementation">Virtual Circuit Implementation</h3>

<p>A virtual circuit comprises:</p>

<ol>
  <li><strong>Path Information</strong>: From source to destination.</li>
  <li><strong>VC Numbers</strong>: Virtual Circuit numbers for each link.</li>
  <li><strong>Forwarding Table Entries</strong>: Information on which output port to use for each VC.</li>
</ol>

<h3 id="forwarding-example">Forwarding Example</h3>

<p>When a datagram is sent from the source to node 1, node 1 will use VC1 for subsequent transmissions to the same destination. Each intermediate node (e.g., nodes 2, 3) and the final destination will follow a similar process, using specific VC numbers for each link.</p>

<h3 id="vc-signaling-protocols">VC Signaling Protocols</h3>

<p>Virtual circuits require signaling protocols for setup, maintenance, and teardown (e.g., ATM, X.25, Frame Relay). While the internet today does not commonly use virtual circuits, these protocols are crucial in certain applications.</p>

<h2 id="data-forwarding-in-datagram-networks">Data Forwarding in Datagram Networks</h2>

<p>In contrast to virtual circuits, datagram networks do not require call setup. Packets are simply pushed into the network. Forwarding tables in datagram networks do not store destination-specific information due to the vast number of possible destinations (e.g., billions in IPv4). Instead, they use hierarchical addressing to manage forwarding more efficiently.</p>

<h3 id="example-hierarchical-addressing">Example: Hierarchical Addressing</h3>

<p>Consider traveling from A to B. You follow general signs towards B, and as you get closer, you see more specific signs guiding you to your exact destination. Similarly, network routers use hierarchical addressing to forward packets more efficiently.</p>

<h2 id="datagram-or-vc-networks-why">Datagram or VC Networks: Why?</h2>

<p>The internet uses datagram networks, whereas ATM uses virtual circuit networks. Simplifying the network core allows for faster packet transmission by reducing processing overhead. Intelligent endpoints (computers) can handle complex tasks, while simpler endpoints (like telephones) benefit from the guaranteed services of virtual circuit networks.</p>

<p>Understanding the role of the network layer and the distinction between virtual circuit and datagram networks is crucial for grasping how modern networks operate. Whether it’s ensuring efficient packet forwarding or setting up reliable virtual circuits, the network layer plays a fundamental role in the seamless operation of communication systems.</p>]]></content><author><name>Max</name><email>maxkim7723@gmail.com</email></author><category term="CS" /><category term="CS" /><category term="Knowledge" /><category term="Quiz" /><category term="Network" /><category term="VirtualCircuits" /><category term="Datagram" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[CS] Frequently Used SQL syntax</title><link href="http://localhost:4000/cs/SQL/" rel="alternate" type="text/html" title="[CS] Frequently Used SQL syntax" /><published>2024-07-16T00:00:00+09:00</published><updated>2024-07-16T00:00:00+09:00</updated><id>http://localhost:4000/cs/SQL</id><content type="html" xml:base="http://localhost:4000/cs/SQL/"><![CDATA[<p><img src="/assets/images/2024-07-11-CSQuiz1/quiz.png" alt="CSQuiz" /></p>

<p>Q. What SQL statement is used to retrieve data from a database?</p>

<p>A. The <code class="language-plaintext highlighter-rouge">SELECT</code> statement is used to fetch data from one or more tables in a database.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table_name</span><span class="p">;</span>
</code></pre></div></div>

<p>Q. How do you insert new data into a table named customers with columns name and email?</p>

<p>A. Use the INSERT INTO statement to add new records to a table.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">customers</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">email</span><span class="p">)</span>
<span class="k">VALUES</span> <span class="p">(</span><span class="s1">'John Doe'</span><span class="p">,</span> <span class="s1">'john@example.com'</span><span class="p">);</span>
</code></pre></div></div>

<p>Q. What SQL keyword is used to modify existing data in a table?</p>

<p>A. The UPDATE statement is used to modify existing records in a table based on specified conditions.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="k">table_name</span>
<span class="k">SET</span> <span class="n">column1</span> <span class="o">=</span> <span class="n">value1</span><span class="p">,</span> <span class="n">column2</span> <span class="o">=</span> <span class="n">value2</span><span class="p">,</span> <span class="p">...</span>
<span class="k">WHERE</span> <span class="n">condition</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="essential-sql-syntax-patterns-for-everyday-use">Essential SQL Syntax Patterns for Everyday Use</h2>

<p>SQL (Structured Query Language) is essential for managing and manipulating data in relational databases. Mastering fundamental SQL syntax patterns empowers developers and analysts to efficiently retrieve, manipulate, and organize data.</p>

<h3 id="creating-an-index">Creating an Index</h3>

<p>Indexes enhance query performance by providing quick access to rows in a table. Use the following syntax to create an index.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">index_name</span>
<span class="k">ON</span> <span class="k">table_name</span> <span class="p">(</span><span class="k">column_name</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="updating-data-with-conditions">Updating Data with Conditions</h3>

<p>Update specific rows in a table based on certain conditions using UPDATE with SET and WHERE clauses.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="k">table_name</span>
<span class="k">SET</span> <span class="n">column1</span> <span class="o">=</span> <span class="n">value1</span><span class="p">,</span> <span class="n">column2</span> <span class="o">=</span> <span class="n">value2</span><span class="p">,</span> <span class="p">...</span>
<span class="k">WHERE</span> <span class="n">condition</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="joining-data-from-multiple-tables">Joining Data from Multiple Tables</h3>
<p>Combine data from different tables using various join types.</p>

<p>Inner Join retrieves rows with matching values in both tables.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">columns</span>
<span class="k">FROM</span> <span class="n">table1</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">table2</span> <span class="k">ON</span> <span class="n">table1</span><span class="p">.</span><span class="k">column_name</span> <span class="o">=</span> <span class="n">table2</span><span class="p">.</span><span class="k">column_name</span><span class="p">;</span>
</code></pre></div></div>

<p>Left Join retrieves all rows from the left table and matching rows from the right table</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">columns</span>
<span class="k">FROM</span> <span class="n">table1</span>
<span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">table2</span> <span class="k">ON</span> <span class="n">table1</span><span class="p">.</span><span class="k">column_name</span> <span class="o">=</span> <span class="n">table2</span><span class="p">.</span><span class="k">column_name</span><span class="p">;</span>
</code></pre></div></div>

<p>Right Join retrieves all rows from the right table and matching rows from the left table.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">columns</span>
<span class="k">FROM</span> <span class="n">table1</span>
<span class="k">RIGHT</span> <span class="k">JOIN</span> <span class="n">table2</span> <span class="k">ON</span> <span class="n">table1</span><span class="p">.</span><span class="k">column_name</span> <span class="o">=</span> <span class="n">table2</span><span class="p">.</span><span class="k">column_name</span><span class="p">;</span>
</code></pre></div></div>

<p>Full Outer Join retrieves all rows when there is a match in either table.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">columns</span>
<span class="k">FROM</span> <span class="n">table1</span>
<span class="k">FULL</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">table2</span> <span class="k">ON</span> <span class="n">table1</span><span class="p">.</span><span class="k">column_name</span> <span class="o">=</span> <span class="n">table2</span><span class="p">.</span><span class="k">column_name</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="inserting-data-into-a-table">Inserting Data into a Table</h3>
<p>Add new rows of data into a table using INSERT INTO.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="k">table_name</span> <span class="p">(</span><span class="n">column1</span><span class="p">,</span> <span class="n">column2</span><span class="p">,</span> <span class="p">...)</span>
<span class="k">VALUES</span> <span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">,</span> <span class="p">...);</span>
</code></pre></div></div>

<h3 id="creating-a-view">Creating a View</h3>
<p>Views are virtual tables derived from one or more base tables. Use CREATE VIEW AS to define a view.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">VIEW</span> <span class="n">view_name</span> <span class="k">AS</span>
<span class="k">SELECT</span> <span class="n">columns</span>
<span class="k">FROM</span> <span class="k">table_name</span>
<span class="k">WHERE</span> <span class="n">condition</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="altering-table-structure">Altering Table Structure</h3>
<p>Modify the structure of a table using ALTER TABLE.</p>

<p>Adding Columns.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span>
<span class="k">ADD</span> <span class="k">column_name</span> <span class="n">datatype</span><span class="p">;</span>
</code></pre></div></div>
<h3 id="ordering-results">Ordering Results</h3>
<p>Sort query results in ascending or descending order using ORDER BY.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">columns</span>
<span class="k">FROM</span> <span class="k">table_name</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="k">column_name</span> <span class="k">ASC</span><span class="o">|</span><span class="k">DESC</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="calculating-rankings">Calculating Rankings</h3>
<p>To rank rows based on certain criteria, such as scores or sales.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span><span class="p">,</span> <span class="p">...,</span> <span class="n">RANK</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">score</span> <span class="k">DESC</span><span class="p">)</span> <span class="k">AS</span> <span class="n">rank</span>
<span class="k">FROM</span> <span class="k">table_name</span><span class="p">;</span>
</code></pre></div></div>

<p>This query ranks rows based on the score column in descending order.
This format should be more suitable for your blog post, providing both SQL code examples and their explanations.</p>]]></content><author><name>Max</name><email>maxkim7723@gmail.com</email></author><category term="CS" /><category term="CS" /><category term="Knowledge" /><category term="Quiz" /><category term="SQL" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">[CS] Understanding Packet Switching: Virtual Circuit and Datagram Methods with Quiz</title><link href="http://localhost:4000/cs/CSQuiz1/" rel="alternate" type="text/html" title="[CS] Understanding Packet Switching: Virtual Circuit and Datagram Methods with Quiz" /><published>2024-07-11T00:00:00+09:00</published><updated>2024-07-11T00:00:00+09:00</updated><id>http://localhost:4000/cs/CSQuiz1</id><content type="html" xml:base="http://localhost:4000/cs/CSQuiz1/"><![CDATA[<p><img src="/assets/images/2024-07-11-CSQuiz1/quiz.png" alt="CSQuiz" /></p>

<ol>
  <li>What term describes the number of unique values in a specific dataset?
    <ul>
      <li>Explanation: Cardinality refers to the distinct count of values within a dataset, indicating how many unique values exist.</li>
    </ul>
  </li>
  <li>What term is used to describe the actual set of data stored in a database table?
    <ul>
      <li>Explanation: A relation instance is the concrete collection of data stored within a database table, also known as the relation or extension.</li>
    </ul>
  </li>
  <li>In the context of databases, what does a tuple represent?
    <ul>
      <li>Explanation: A tuple refers to a single row or record within a database table, containing data fields corresponding to the table’s attributes.</li>
    </ul>
  </li>
  <li>Which protocol is used to send error messages and operational information in IP networks?
    <ul>
      <li>Explanation: ICMP is essential for network troubleshooting by reporting errors and providing feedback on IP packet transmission.</li>
    </ul>
  </li>
  <li>What term describes a program that self-replicates and spreads to other computers through network connections?
    <ul>
      <li>Explanation: A virus is a type of malware that replicates itself and spreads to other computers by attaching to host files or through network transmissions.</li>
    </ul>
  </li>
  <li>Which protocol provides secure remote access to a computer or server, offering stronger security than Telnet?
    <ul>
      <li>Explanation: SSH encrypts communication sessions between computers, providing secure remote access and file transfer capabilities.</li>
    </ul>
  </li>
  <li>What term describes a unit of data transmitted independently over a network without establishing a connection?
    <ul>
      <li>Explanation: A datagram is a self-contained packet of data sent across a network without a prior setup of connection paths, commonly used in packet-switched networks.</li>
    </ul>
  </li>
  <li>In networking, what is a pre-defined logical communication path between sender and receiver stations called?
    <ul>
      <li>Explanation: A virtual circuit is a predetermined logical route in packet-switched networks, ensuring ordered and reliable data transmission between endpoints.</li>
    </ul>
  </li>
  <li>What web development technique enables asynchronous loading of web page content, allowing users to interact with web pages more dynamically?
    <ul>
      <li>Explanation: AJAX facilitates updating specific parts of a web page without refreshing the entire page, enhancing user interaction and responsiveness in web applications.</li>
    </ul>
  </li>
  <li>What term describes a program that appears benign but performs malicious actions when executed?
    <ul>
      <li>Explanation: A Trojan horse disguises itself as legitimate software to deceive users into executing harmful actions.</li>
    </ul>
  </li>
  <li>Which protocol is used to send error messages and operational information in IP networks?
    <ul>
      <li>Explanation: ICMP is essential for network troubleshooting by reporting errors and providing feedback on IP packet transmission.</li>
    </ul>
  </li>
</ol>

<h2 id="understanding-packet-switching-virtual-circuit-and-datagram-methods">Understanding Packet Switching: Virtual Circuit and Datagram Methods</h2>

<p>Packet switching is a method of transmitting messages by dividing them into packets of a certain length. This method is fundamental to modern networking and can be categorized into two types: virtual circuit switching and datagram switching.</p>

<h3 id="virtual-circuit-switching">Virtual Circuit Switching</h3>

<p>Virtual circuit switching establishes a logical virtual communication circuit between terminals before transmission. Here’s how it works:</p>

<ul>
  <li><strong>Pre-established Route</strong>: A logical communication circuit is set up between the sender and receiver in advance, confirming the connection before transmission.</li>
  <li><strong>Control Packets</strong>: The route is set by a control packet before any information is sent.</li>
  <li><strong>Order Preservation</strong>: All packets are transmitted sequentially along the same route, ensuring that the order of transmission and reception is maintained.</li>
</ul>

<h3 id="datagram-switching">Datagram Switching</h3>

<p>Datagram switching, on the other hand, does not set a connection route. Instead, it relies on the current traffic conditions and independently handles each packet. Here are its key characteristics:</p>

<ul>
  <li><strong>No Pre-set Route</strong>: It does not establish a fixed connection route. Instead, it monitors the traffic status of accessible nodes and distributes packets accordingly.</li>
  <li><strong>Independent Packets</strong>: Each packet may have a different transmission route and carries the complete address of the destination.</li>
  <li><strong>Reordering at Destination</strong>: Packets might arrive at the destination through various routes and in different orders, requiring reordering at the receiving end.</li>
</ul>

<p>Understanding the differences between virtual circuit switching and datagram switching is crucial for grasping how data is transmitted over networks. Each method has its unique advantages and is suitable for different types of network communication.</p>]]></content><author><name>Max</name><email>maxkim7723@gmail.com</email></author><category term="CS" /><category term="CS" /><category term="Knowledge" /><category term="Quiz" /><category term="Network" /><category term="Packet Switching" /><summary type="html"><![CDATA[]]></summary></entry></feed>